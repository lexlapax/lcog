package chromem_go

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"time"

	"github.com/lexlapax/cogmem/pkg/entity"
	"github.com/lexlapax/cogmem/pkg/log"
	"github.com/lexlapax/cogmem/pkg/mem/ltm"
	chromem "github.com/philippgille/chromem-go"
)

var (
	// ErrMissingQueryVector is returned when a semantic search is attempted without a query vector
	ErrMissingQueryVector = errors.New("missing query vector for semantic search")
	
	// ErrRecordNotFound is returned when a record with the specified ID doesn't exist
	ErrRecordNotFound = errors.New("record not found")
	
	// ErrChromemGoUnavailable is returned when the chromem-go client is unavailable
	ErrChromemGoUnavailable = errors.New("chromem-go client unavailable")
)

// Metadata keys used for filtering records
const (
	MetadataKeyID          = "id"
	MetadataKeyEntityID    = "entity_id"
	MetadataKeyUserID      = "user_id"
	MetadataKeyAccessLevel = "access_level"
	MetadataKeyCreatedAt   = "created_at"
	MetadataKeyUpdatedAt   = "updated_at"
)

// ChromemGoAdapter implements the ltm.LTMStore interface using chromem-go as the backend
type ChromemGoAdapter struct {
	client         *chromem.DB
	collectionName string
	collection     *chromem.Collection
}

// NewChromemGoAdapter creates a new adapter for chromem-go
func NewChromemGoAdapter(client *chromem.DB, collectionName string) (*ChromemGoAdapter, error) {
	if client == nil {
		return nil, errors.New("client cannot be nil")
	}

	if collectionName == "" {
		return nil, errors.New("collection name cannot be empty")
	}

	// Create a default embedding function
	embeddingFunc := func(ctx context.Context, text string) ([]float32, error) {
		// This is a placeholder that returns a default embedding
		// In a real implementation, this would call to the reasoning engine
		return []float32{0.1, 0.2, 0.3, 0.4, 0.5}, nil
	}

	// Create or get collection
	collection, err := client.GetOrCreateCollection(collectionName, nil, embeddingFunc)
	if err != nil {
		return nil, fmt.Errorf("failed to create/get collection: %w", err)
	}

	return &ChromemGoAdapter{
		client:         client,
		collectionName: collectionName,
		collection:     collection,
	}, nil
}

// Store persists a memory record to chromem-go
func (a *ChromemGoAdapter) Store(ctx context.Context, record ltm.MemoryRecord) (string, error) {
	// Use the existing ID or generate a new one
	recordID := record.ID
	if recordID == "" {
		recordID = fmt.Sprintf("rec-%d", time.Now().UnixNano())
		record.ID = recordID
	}

	// Ensure timestamps are set
	now := time.Now()
	if record.CreatedAt.IsZero() {
		record.CreatedAt = now
	}
	if record.UpdatedAt.IsZero() {
		record.UpdatedAt = now
	}

	// Prepare metadata for chromem-go (convert to string keys and values)
	metadata := make(map[string]string)
	
	// Add system metadata for filtering
	metadata[MetadataKeyID] = record.ID
	metadata[MetadataKeyEntityID] = string(record.EntityID)
	metadata[MetadataKeyUserID] = record.UserID
	metadata[MetadataKeyAccessLevel] = strconv.Itoa(int(record.AccessLevel))
	metadata[MetadataKeyCreatedAt] = record.CreatedAt.Format(time.RFC3339)
	metadata[MetadataKeyUpdatedAt] = record.UpdatedAt.Format(time.RFC3339)
	
	// Add user metadata
	if record.Metadata != nil {
		for k, v := range record.Metadata {
			if str, ok := v.(string); ok {
				metadata[k] = str
			} else {
				// Convert non-string values to strings
				metadata[k] = fmt.Sprintf("%v", v)
			}
		}
	}

	// Ensure we have an embedding
	embedding := record.Embedding
	if embedding == nil || len(embedding) == 0 {
		// Use a default embedding for now
		// In a real implementation, this would be generated by calling the reasoning engine
		embedding = []float32{0.1, 0.2, 0.3, 0.4, 0.5}
	}

	// Create a chromem document
	doc := chromem.Document{
		ID:        record.ID,
		Content:   record.Content,
		Embedding: embedding,
		Metadata:  metadata,
	}

	// Store the document in chromem-go
	err := a.collection.AddDocument(ctx, doc)
	if err != nil {
		return "", fmt.Errorf("failed to add document: %w", err)
	}
	
	// Log success for debugging
	log.Debug("Document stored successfully", 
		"id", doc.ID, 
		"collection", a.collectionName,
		"metadata_keys", fmt.Sprintf("%v", doc.Metadata))

	log.Debug("Stored record in chromem-go", 
		"id", record.ID, 
		"entity_id", record.EntityID,
		"collection", a.collectionName)

	return record.ID, nil
}

// Retrieve fetches memory records matching the query
func (a *ChromemGoAdapter) Retrieve(ctx context.Context, query ltm.LTMQuery) ([]ltm.MemoryRecord, error) {
	if a.collection == nil {
		return nil, ErrChromemGoUnavailable
	}

	// Determine the retrieval mode based on the query
	var results []chromem.Result
	var err error

	switch {
	case query.ExactMatch != nil && query.ExactMatch["id"] != nil:
		// ID-based lookup
		recordID, ok := query.ExactMatch["id"].(string)
		if !ok {
			return nil, errors.New("invalid record ID in query")
		}
		results, err = a.retrieveByID(ctx, recordID)
	case len(query.Embedding) > 0:
		// Semantic search with vector
		results, err = a.retrieveSemantic(ctx, query)
	default:
		// Filter-based search
		results, err = a.retrieveByFilters(ctx, query)
	}

	if err != nil {
		return nil, err
	}

	// Convert from chromem.Result to ltm.MemoryRecord
	records := a.convertToMemoryRecords(results)
	return records, nil
}

// retrieveByID retrieves a record by its ID
func (a *ChromemGoAdapter) retrieveByID(ctx context.Context, recordID string) ([]chromem.Result, error) {
	// Create filter for document ID
	where := map[string]string{
		"id": recordID,
	}
	
	// Count the total number of documents in the collection first
	count := countDocumentsInCollection(a.collection)
	if count == 0 {
		// No documents in collection, return empty result
		return []chromem.Result{}, nil
	}
	
	// Query with a dummy embedding instead of an empty query string
	dummyEmbedding := []float32{0.1, 0.2, 0.3, 0.4, 0.5}
	results, err := a.collection.QueryEmbedding(ctx, dummyEmbedding, 1, where, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to query by ID: %w", err)
	}
	
	// Log query results for debugging
	log.Debug("Query by ID results", 
		"id", recordID, 
		"count", len(results),
		"where", fmt.Sprintf("%v", where))

	return results, nil
}

// retrieveSemantic performs semantic search with the query vector
func (a *ChromemGoAdapter) retrieveSemantic(ctx context.Context, query ltm.LTMQuery) ([]chromem.Result, error) {
	if len(query.Embedding) == 0 {
		return nil, ErrMissingQueryVector
	}

	// Build the where clause for filtering
	where := make(map[string]string)
	
	// Process filters from Filters map
	if query.Filters != nil {
		// Add entity filter if specified
		if entityID, ok := query.Filters["entity_id"].(entity.EntityID); ok && entityID != "" {
			where["entity_id"] = string(entityID)
		}
		
		// Add user filter if specified
		if userID, ok := query.Filters["user_id"].(string); ok && userID != "" {
			where["user_id"] = userID
		}
		
		// Add access level filter if specified
		if accessLevel, ok := query.Filters["access_level"].(entity.AccessLevel); ok {
			where["access_level"] = strconv.Itoa(int(accessLevel))
		}
	}

	// Set default limit if not specified
	limit := query.Limit
	if limit <= 0 {
		limit = 10
	}

	// Query documents
	results, err := a.collection.QueryEmbedding(ctx, query.Embedding, limit, where, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to perform semantic search: %w", err)
	}

	return results, nil
}

// retrieveByFilters retrieves records using metadata filters
func (a *ChromemGoAdapter) retrieveByFilters(ctx context.Context, query ltm.LTMQuery) ([]chromem.Result, error) {
	// Build the where clause for filtering
	where := make(map[string]string)
	
	// Process exact match criteria
	if query.ExactMatch != nil {
		for k, v := range query.ExactMatch {
			if k == "id" {
				continue // Skip ID as it's handled separately
			}
			
			switch val := v.(type) {
			case string:
				where[k] = val
			case entity.EntityID:
				where[k] = string(val)
			case int:
				where[k] = strconv.Itoa(val)
			case bool:
				where[k] = strconv.FormatBool(val)
			case entity.AccessLevel:
				where[k] = strconv.Itoa(int(val))
			}
		}
	}
	
	// Process general filters
	if query.Filters != nil {
		for k, v := range query.Filters {
			switch val := v.(type) {
			case string:
				where[k] = val
			case entity.EntityID:
				where[k] = string(val)
			case int:
				where[k] = strconv.Itoa(val)
			case bool:
				where[k] = strconv.FormatBool(val)
			case entity.AccessLevel:
				where[k] = strconv.Itoa(int(val))
			}
		}
	}

	// Set default limit if not specified
	limit := query.Limit
	if limit <= 0 {
		limit = 10
	}

	// Count the total number of documents in the collection first
	// This is a workaround for the error: "nResults must be <= the number of documents in the collection"
	count := countDocumentsInCollection(a.collection)
	if count == 0 {
		// No documents in collection, return empty result
		return []chromem.Result{}, nil
	}
	
	// Adjust limit if necessary
	if limit > count {
		limit = count
	}

	var results []chromem.Result
	var err error

	// If text search is specified, use Query with the text
	if query.Text != "" {
		results, err = a.collection.Query(ctx, query.Text, limit, where, nil)
		if err != nil {
			return nil, fmt.Errorf("failed to query by text: %w", err)
		}
	} else {
		// Use a default dummy embedding for metadata-only search
		// The API requires a non-empty embedding, but we'll ignore the vector distance in the results
		dummyEmbedding := []float32{0.1, 0.2, 0.3, 0.4, 0.5}
		results, err = a.collection.QueryEmbedding(ctx, dummyEmbedding, limit, where, nil)
		if err != nil {
			return nil, fmt.Errorf("failed to query by filters: %w", err)
		}
	}

	return results, nil
}

// countDocumentsInCollection is a helper function that counts the total number of documents in a collection
func countDocumentsInCollection(collection *chromem.Collection) int {
	// In a real implementation, you'd use the collection's API to count documents
	// But for now, we'll make a simple query that returns all documents
	// Since we're only using this for testing, this simplistic approach is acceptable
	// In production, you'd want a more efficient way to count documents
	
	// Try to get all documents with a very large limit and no filter
	// This is a simplistic approach just for tests
	results, err := collection.QueryEmbedding(context.Background(), []float32{0.1, 0.2, 0.3, 0.4, 0.5}, 10000, nil, nil)
	if err != nil {
		// If there's an error, assume there are no documents
		return 0
	}
	
	return len(results)
}

// Update modifies an existing memory record
func (a *ChromemGoAdapter) Update(ctx context.Context, record ltm.MemoryRecord) error {
	if record.ID == "" {
		return errors.New("record ID cannot be empty")
	}

	// Check if the record exists
	where := map[string]string{
		"id": record.ID,
	}
	
	// Use QueryEmbedding with a dummy embedding
	dummyEmbedding := []float32{0.1, 0.2, 0.3, 0.4, 0.5}
	results, err := a.collection.QueryEmbedding(ctx, dummyEmbedding, 1, where, nil)
	if err != nil {
		return fmt.Errorf("failed to check if record exists: %w", err)
	}

	if len(results) == 0 {
		return ErrRecordNotFound
	}

	// Delete the existing record
	err = a.collection.Delete(ctx, where, nil, record.ID)
	if err != nil {
		return fmt.Errorf("failed to delete existing record for update: %w", err)
	}

	// Update the timestamp
	record.UpdatedAt = time.Now()

	// Store the updated record
	_, err = a.Store(ctx, record)
	return err
}

// Delete removes a memory record
func (a *ChromemGoAdapter) Delete(ctx context.Context, id string) error {
	if id == "" {
		return errors.New("record ID cannot be empty")
	}

	// Delete the document by ID
	err := a.collection.Delete(ctx, nil, nil, id)
	if err != nil {
		return fmt.Errorf("failed to delete document: %w", err)
	}

	log.Debug("Deleted record from chromem-go", 
		"id", id, 
		"collection", a.collectionName)

	return nil
}

// convertToMemoryRecords converts chromem-go query results to MemoryRecord objects
func (a *ChromemGoAdapter) convertToMemoryRecords(results []chromem.Result) []ltm.MemoryRecord {
	if len(results) == 0 {
		return []ltm.MemoryRecord{}
	}

	records := make([]ltm.MemoryRecord, 0, len(results))

	for _, result := range results {
		// Get the ID
		recordID := result.ID

		// Get entity ID
		entityIDStr, ok := result.Metadata[MetadataKeyEntityID]
		if !ok {
			log.Warn("Document missing entity ID", "id", result.ID)
			continue
		}
		entityID := entity.EntityID(entityIDStr)

		// Parse access level
		accessLevelStr, ok := result.Metadata[MetadataKeyAccessLevel]
		if !ok {
			log.Warn("Document missing access level", "id", result.ID)
			continue
		}
		accessLevel, err := strconv.Atoi(accessLevelStr)
		if err != nil {
			log.Warn("Failed to parse access level", "id", result.ID, "access_level", accessLevelStr, "error", err)
			continue
		}

		// Parse timestamps
		createdAtStr, ok := result.Metadata[MetadataKeyCreatedAt]
		if !ok {
			log.Warn("Document missing created timestamp", "id", result.ID)
			continue
		}
		createdAt, err := time.Parse(time.RFC3339, createdAtStr)
		if err != nil {
			log.Warn("Failed to parse created timestamp", "id", result.ID, "created_at", createdAtStr, "error", err)
			continue
		}

		updatedAtStr, ok := result.Metadata[MetadataKeyUpdatedAt]
		if !ok {
			log.Warn("Document missing updated timestamp", "id", result.ID)
			continue
		}
		updatedAt, err := time.Parse(time.RFC3339, updatedAtStr)
		if err != nil {
			log.Warn("Failed to parse updated timestamp", "id", result.ID, "updated_at", updatedAtStr, "error", err)
			continue
		}

		// Extract user ID
		userID := result.Metadata[MetadataKeyUserID]

		// Create metadata map excluding system metadata
		metadata := make(map[string]interface{})
		for k, v := range result.Metadata {
			// Skip system metadata
			if k == MetadataKeyID || k == MetadataKeyEntityID || k == MetadataKeyUserID ||
				k == MetadataKeyAccessLevel || k == MetadataKeyCreatedAt || k == MetadataKeyUpdatedAt {
				continue
			}
			metadata[k] = v
		}

		// Create the memory record
		record := ltm.MemoryRecord{
			ID:          recordID,
			EntityID:    entityID,
			UserID:      userID,
			AccessLevel: entity.AccessLevel(accessLevel),
			Content:     result.Content,
			Metadata:    metadata,
			Embedding:   result.Embedding,
			CreatedAt:   createdAt,
			UpdatedAt:   updatedAt,
		}

		records = append(records, record)
	}

	return records
}

// SupportsVectorSearch returns true as this adapter supports vector search
func (a *ChromemGoAdapter) SupportsVectorSearch() bool {
	return true
}